/* sdlui/image.c: image resources.
 */

#include <SDL.h>
#include "./gen.h"
#include "./types.h"
#include "./incbin.h"
#include "internal.h"
#include "getpng.h"
#include "image.h"

/* The image providing the complete set of playing cards.
 *
 * The playing cards are laid out in a 16x4 array. Each of the four
 * rows contains all the cards for one suit. The first two columns
 * contain special graphics. The actual cards begin with the aces in
 * the third column, then the twos, and so on up to the kings in the
 * next-to-last column.
 *
 * The contents of the first column, going from top to bottom, are the
 * index marker graphic, an "empty" image indicating a location
 * without a card, a mask for the empty image, and a blank card. The
 * index marker graphic is not an actual image, but rather a black
 * image with red pixels that indicate the position of the cards'
 * corner index labels.
 *
 * The second column contains four "empty" card images that indicate
 * the suit required for cards played there, such as appear at an
 * empty foundation pile.
 *
 * (The final column contains two jokers and two card backs, neither
 * of which are used by this program.)
 */
INCBIN("sdlui/cardset.png", pngcardset, pngcardset_end);

/* The two images used to create the title graphic for the list
 * display.
 */
INCBIN("sdlui/banner.png", pngbanner, pngbanner_end);
INCBIN("sdlui/headline.png", pngheadline, pngheadline_end);

/* Two collections of smaller images, stored in the manner of a sprite
 * sheet. The first file contains indicator graphics, or "alerts", and
 * the second contains button labels. Individual images are identified
 * using values defined in sdlui/alertids.h and sdlui/labelids.h, and
 * are located via the SDL_Rect arrays defined below.
 */
INCBIN("sdlui/alerts.png", pngalerts, pngalerts_end);
INCBIN("sdlui/labels.png", pnglabels, pnglabels_end);

/* The arrays containing the position and size of each separate
 * sub-image in the sprite sheet resources. The actual values come
 * from header files generated by the sprite layout data, and so need
 * to be included into the variable initialization statements.
 */
static SDL_Rect const alertrects[] = {
#include "sdlui/alertpos.h"
};

static SDL_Rect const labelrects[] = {
#include "sdlui/labelpos.h"
};

/* The texture containing the playing cards.
 */
static SDL_Texture *decktexture;

/* The location of each card in the texture.
 */
static SDL_Rect cardrects[64];

/* The texture containing the alert graphics.
 */
static SDL_Texture *alerttexture = NULL;

/* The button labels. These need to be in a surface, since they will
 * be copied into other surfaces. Once all of the buttons have been
 * created, this surface will be deallocated.
 */
static SDL_Surface *labelsurface = NULL;

/* Examine the pixels inside a rectangle in the top-left corner of the
 * image, with the given size, and locate the block of bright red
 * pixels. (These pixels mark the location of the index of the playing
 * cards.) Return the y-coordinate of the first line of pixels below
 * the red shape.
 */
static int finddropheight(SDL_Surface *image, SDL_Point size)
{
    Uint8 *pixels, *p;
    Uint32 value;
    int height;
    int x, y;

    if (SDL_MUSTLOCK(image))
        SDL_LockSurface(image);
    pixels = image->pixels;

    height = size.y / 2;
    if (image->format->BitsPerPixel == 8) {
        value = SDL_MapRGB(image->format, 255, 0, 0);
        for (y = 0 ; y < size.y / 2 ; ++y) {
            for (x = 0 ; x < size.x ; ++x) {
                if (pixels[x] == value) {
                    height = y;
                    break;
                }
            }
            pixels += image->pitch;
        }
    } else {
        for (y = 0 ; y < size.y / 2 ; ++y) {
            p = pixels;
            for (x = 0 ; x < size.x ; ++x) {
                switch (image->format->BitsPerPixel) {
                  case 16:
                    value = *(Uint16*)p;
                    p += 2;
                    break;
                  case 32:
                    value = *(Uint32*)p;
                    p += 4;
                    break;
                  case 24:
#if SDL_BYTEORDER == SDL_BIG_ENDIAN
                    value = *(Uint32*)pixels >> 8;
#else
                    value = *(Uint32*)pixels & 0x00FFFFFF;
#endif
                    p += 3;
                    break;
                  default:
                    value = *p++;
                    break;
                }
                if ((value & image->format->Rmask) == image->format->Rmask) {
                    height = y;
                    break;
                }
            }
            pixels += image->pitch;
        }
    }

    if (SDL_MUSTLOCK(image))
        SDL_UnlockSurface(image);
    return height + 1;
}

/* Create the texture holding the playing card images, and locate each
 * card within the texture.
 */
static void initdeck(void)
{
    SDL_Surface *image;
    int i, x, y;

    image = pngtosurface(pngcardset);
    decktexture = SDL_CreateTextureFromSurface(_graph.renderer, image);
    SDL_QueryTexture(decktexture, NULL, NULL, &x, &y);
    _graph.cardsize.x = x / 16;
    _graph.cardsize.y = y / 4;
    _graph.dropheight = finddropheight(image, _graph.cardsize);
    SDL_FreeSurface(image);

    for (i = 0 ; i < 64 ; ++i) {
        cardrects[i].x = (i / 4) * _graph.cardsize.x;
        cardrects[i].y = (i % 4) * _graph.cardsize.y;
        cardrects[i].w = _graph.cardsize.x;
        cardrects[i].h = _graph.cardsize.y;
    }
}

/*
 * Internal functions.
 */

/* Return the width of the given alert graphic.
 */
int getimagewidth(int id)
{
    return alertrects[id].w;
}

/* Return the height of the given alert graphic.
 */
int getimageheight(int id)
{
    return alertrects[id].h;
}

/* Load the playing cards and the two image sheets. The button images
 * remains in main memory only.
 */
void initializeimages(void)
{
    SDL_Surface *image;

    initdeck();
    labelsurface = pngtosurface(pnglabels);
    image = pngtosurface(pngalerts);
    alerttexture = SDL_CreateTextureFromSurface(_graph.renderer, image);
    SDL_FreeSurface(image);
}

/* Make a copy of a button label.
 */
SDL_Surface *getbuttonlabel(int id)
{
    SDL_Surface *image;

    image = SDL_CreateRGBSurface(0, labelrects[id].w, labelrects[id].h,
                                 labelsurface->format->BitsPerPixel,
                                 labelsurface->format->Rmask,
                                 labelsurface->format->Gmask,
                                 labelsurface->format->Bmask,
                                 labelsurface->format->Amask);
    SDL_BlitSurface(labelsurface, &labelrects[id], image, NULL);
    SDL_SetSurfaceBlendMode(image, SDL_BLENDMODE_NONE);
    return image;
}

/* Deallocate the button label surface once the program has finished
 * initializing.
 */
void finalizeimages(void)
{
    SDL_FreeSurface(labelsurface);
    labelsurface = NULL;
}

/* Return the splash screen's banner images as textures.
 */
void loadsplashgraphics(SDL_Texture **pbanner, SDL_Texture **pheadline)
{
    SDL_Surface *image;

    image = pngtosurface(pngbanner);
    *pbanner = SDL_CreateTextureFromSurface(_graph.renderer, image);
    SDL_FreeSurface(image);
    image = pngtosurface(pngheadline);
    *pheadline = SDL_CreateTextureFromSurface(_graph.renderer, image);
    SDL_FreeSurface(image);
}

/* Render the given card at the given location.
 */
void rendercard(card_t card, int x, int y)
{
    SDL_Rect rect;

    rect.x = x;
    rect.y = y;
    rect.w = cardrects->w;
    rect.h = cardrects->h;
    SDL_RenderCopy(_graph.renderer, decktexture, &cardrects[card], &rect);
}

/* Render an alert image at the given location.
 */
void renderimage(int id, int x, int y)
{
    SDL_Rect rect;

    rect.x = x;
    rect.y = y;
    rect.w = alertrects[id].w;
    rect.h = alertrects[id].h;
    SDL_RenderCopy(_graph.renderer, alerttexture, &alertrects[id], &rect);
}

/* Render an alert image with the given alpha blending value.
 */
void renderalphaimage(int id, int alpha, int x, int y)
{
    SDL_SetTextureAlphaMod(alerttexture, alpha);
    renderimage(id, x, y);
    SDL_SetTextureAlphaMod(alerttexture, SDL_ALPHA_OPAQUE);
}
